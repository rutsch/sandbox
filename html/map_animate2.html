<!DOCTYPE html>
<!--[if IEMobile 7 ]>    <html class="no-js iem7"> <![endif]-->
<!--[if (gt IEMobile 7)|!(IEMobile)]><!--> <html class="no-js"> <!--<![endif]-->
	<head>
		<meta charset="utf-8">
		<title></title>
		<meta name="description" content="">
		<meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no">
		<link rel="stylesheet" type="text/css" href="css/style.css"/>
		<style type="text/css">
			body{
				font-family: arial;
				font-size: 12px;
			}

		</style>

	</head>
	<body>
		<div id="btn_reload" onclick="location.reload()">Reload</div>
		<div style="position: absolute; z-index: 100; top: 200px; left: 200px; background-color: blue; width: 5px; height: 5px;">.</div>

		<svg id="svgnode" style="overflow: hidden; position: relative;" height="320" width="320" version="1.1" viewBox="0 0 320 320" xmlns="http://www.w3.org/2000/svg">
			<g id="viewport" preserveAspectRatio="xMinYMin" transform="">
				<circle id="svg_circle" r="50" cx="160" cy="160" fill="slategrey" stroke="#000" stroke-width="7"></circle>
				<rect x="50" y="30" width="100" height="100" fill="red" stroke="#000" stroke-width="2"></rect> 
				<circle r="5" cx="30" cy="15" fill="#000"></circle>
				<circle r="5" cx="100" cy="85" fill="#000"></circle>
			</g>
		</svg>
		



		<script type="text/javascript" src="js/plugins/CSSPlugin.min.js">//</script>
		<script type="text/javascript" src="js/plugins/RaphaelPlugin.js">//</script>
		<script type="text/javascript" src="js/easing/EasePack.min.js">//</script>
		<script type="text/javascript" src="js/TweenLite.js">//</script>
		
		
		<script type="text/javascript">

			/*
			Utilities
			*/
			function getEl(id) {
				return document.getElementById(id);
			}
			function logAction(event, elThis, strType){
				console.log(strType);
				console.log(event);
			}

			function findPos(obj) {
				var curleft = curtop = 0;
				if (obj.offsetParent) {
					do {
						curleft += obj.offsetLeft;
						curtop += obj.offsetTop;
					} while (obj = obj.offsetParent);
				}
				return [curleft,curtop];
			}





			//settings for the touch system
			var objTouchSettings={
				debug: true,
				debugtoconsole: true,
				debugtointerface: true,
				zoommax: 5,
				zoommin: 0.2
			}

			//data that will be updated while touching the screen
			var objTouchVars={
				dragging: false,
				timer1: null,
				timer2: null,
				timer3: null,
				zoom: 1,
				zoomworking: 1,
				fingerx: null,
				fingery: null,
				pinchsize: 0,
				pinchscale: 1,
				sampling: false,
				action: ''
			}


			//zooms a svg node
			var viewBoxWidth = 320;
			var viewBoxHeight = 320;

			var viewBox={};
			viewBox.X = 0;
			viewBox.Y = 0;

			function zoomSvg(elSvg, objSvgProperties, intAnimationDurationInSeconds, objAnimationProperties){
				if(objTouchSettings.debug && objTouchSettings.debugtoconsole){
					if(window.console){
						console.log('---');
						//console.log(objSvgProperties);
						console.log('objSvgProperties.transformmatrix.e: '+objSvgProperties.transformmatrix.e+' objSvgProperties.transformmatrix.f: '+objSvgProperties.transformmatrix.f);
						console.log(elSvg.getCTM());
						

					}

				}

				//console.log(objSvgProperties);
				var bolUseAnimation=true;
				var zoomLevel=objAnimationProperties.zoom;
				var intRelativefingerX=objAnimationProperties.fingerx-objSvgProperties.x;
				var intRelativefingerY=objAnimationProperties.fingery-objSvgProperties.y;		
						
				/*
				//translate the position on the screen to a position on the svg node

				console.log('intRelativefingerX: '+intRelativefingerX+' intRelativefingerY: '+intRelativefingerY);

				//calculate the end position of the svg node after zoom is done
				
				//var intTranslateX=(0-objAnimationProperties.relativefingerx)*(zoomLevel-1)+objSvgProperties.transformmatrix.e;
				//var intTranslateY=(0-objAnimationProperties.relativefingery)*(zoomLevel-1)+objSvgProperties.transformmatrix.f;

				//+(0-objSvgProperties.transformmatrix.e)
				//+(0-objSvgProperties.transformmatrix.f)

				var intTranslateX=(0-intRelativefingerX)*(zoomLevel-1);
				console.log('(0-intRelativefingerX)*(zoomLevel-1)='+'(0 - '+intRelativefingerX+')*('+zoomLevel+'-1)');
				var intTranslateY=(0-intRelativefingerY)*(zoomLevel-1);

				console.log('intTranslateX: '+intTranslateX+' intTranslateY: '+intTranslateY);
				console.log('---');
				*/

				//remember the original values
				var vBHo = viewBoxHeight;
				var vBWo = viewBoxWidth;
				var intViewboxXOriginal=viewBox.X;
				var intViewboxYOriginal=viewBox.Y;

				//calculate the new values
				//invert zoom levels..
				//4 -> 0.25
				viewBoxWidth*=(1/zoomLevel);
				viewBoxHeight*=(1/zoomLevel);

				//correction here for the mouse/finger position
				viewBox.X -= ((viewBoxWidth - vBWo) / 2)+((intRelativefingerX*zoomLevel)/2);
				viewBox.Y -= ((viewBoxHeight - vBHo) / 2)+((intRelativefingerY*zoomLevel)/2); 

				//start values
				var objTweenProps={
					vbx: intViewboxXOriginal,
					vby: intViewboxYOriginal,
					vbw: vBWo,
					vbh: vBHo
				}


				if(bolUseAnimation){
					/* use tweenlite to perform the zoom action */
					TweenLite.to(objTweenProps, intAnimationDurationInSeconds, {
						vbx: viewBox.X,
						vby: viewBox.Y,
						vbw: viewBoxWidth,
						vbh: viewBoxHeight,
						onUpdate: function(){
							//console.log(objTweenProps);
							elSvg.setAttributeNS( null, 'viewBox', objTweenProps.vbx+' '+objTweenProps.vby+' '+objTweenProps.vbw+' '+objTweenProps.vbh);


							//svgSetTransform(elSvg, objSvgProperties)

						},
						onComplete: function(){
							//alert('done');
						}
					});

				}else{
					/* set it without animating */
					objSvgProperties.translatex=intTranslateX;
					objSvgProperties.translatey=intTranslateY;
					objSvgProperties.scale=zoomLevel;
					svgSetTransform(elSvg, objSvgProperties);
				}


			}

			//sets the transform attribute on the passed svg node
			function svgSetTransform(elSvg, objSvgProperties){
				var bolUseStringMethod=false;

				if(bolUseStringMethod){
					/* string method */
					//var strTransformValue='translate('+objSvgProperties['translatex']+', '+objSvgProperties['translatey']+') scale('+objSvgProperties['scale']+')';
					var strTransformValue='matrix('+objSvgProperties.scale+',0,0,'+objSvgProperties.scale+','+objSvgProperties.translatex+','+objSvgProperties.translatey+')';
					elSvg.setAttributeNS( null, 'transform', strTransformValue);
				}else{
					/* native method */
					//set the new values for the transform matrix
					objSvgProperties.transformmatrix.a=objSvgProperties.scale;
					objSvgProperties.transformmatrix.b=0;
					objSvgProperties.transformmatrix.c=0;
					objSvgProperties.transformmatrix.d=objSvgProperties.scale;
					objSvgProperties.transformmatrix.e=objSvgProperties.translatex;
					objSvgProperties.transformmatrix.f=objSvgProperties.translatey;

					//console.log(objSvgProperties.transformmatrix);

					//someitem.ownerSVGElement.createSVGTransformFromMatrix(m)
					var svgTransform=elSvg.ownerSVGElement.createSVGTransformFromMatrix(objSvgProperties.transformmatrix);
					//console.log(bla);

					elSvg.transform.baseVal.initialize(svgTransform);
				}

			}

			//retrieves the svg element properties (typically <g/> element)
			function retrieveSvgElementObject(elSvg){
				objSvgElementProperties={};

				//1- set the current values into the object
				objSvgElementProperties.translatex=0;
				objSvgElementProperties.translatey=0;
				objSvgElementProperties.scale=1;				
				
				//2- position of the element in the browser
				var arrPosition=findPos(elSvg);
				objSvgElementProperties.x=arrPosition[0];
				objSvgElementProperties.y=arrPosition[1];
				
				//3- store the attributes of the svg node into the object too
				for (var attr, i=0, attrs=objPageElements.rootanimate.attributes, l=attrs.length; i<l; i++){
					attr = attrs.item(i);
					//alert(attr.nodeName);
					if(attr.nodeName=='transform'){
						//alert(attr.nodeValue);
						//perform srting manipulation to find all the values used in the transform
					}
					objSvgElementProperties[attr.nodeName]=attr.nodeValue;
				}

				//4- the svg transform object (this allows us to read the position, scale etc of the svg element)
				objSvgElementProperties.transformmatrix=elSvg.getCTM();

				//5- the svg size
				objSvgElementProperties.size=elSvg.getBoundingClientRect();


				return objSvgElementProperties;
			}


			/*
			Executes page logic
			*/
			function initPage() {
				//init global objects
				objPageElements.rootanimate=getEl('svgnode');
				
				//prepare an object containing vital information about the svg element to animate
				objPageElements.rootanimateattributevalues=retrieveSvgElementObject(objPageElements.rootanimate);

				console.log(objPageElements.rootanimateattributevalues);



				//start an animation sequence
				var objAnimationProperties={};
				objTouchVars.timer1=setTimeout(function(){
					objAnimationProperties.zoom=5;
					objAnimationProperties.fingerx=30;
					objAnimationProperties.fingery=30;

					zoomSvg(objPageElements.rootanimate, objPageElements.rootanimateattributevalues, 2, objAnimationProperties);

					
					objTouchVars.timer2=setTimeout(function(){
											
						objAnimationProperties.zoom=3;
						objAnimationProperties.fingerx=30;
						objAnimationProperties.fingery=30;

						zoomSvg(objPageElements.rootanimate, objPageElements.rootanimateattributevalues, 2, objAnimationProperties);
					}, 2050)
					/**/

				}, 800)





			}

			function onResize(){
				objPageVars.width = document.body.clientWidth;
				objPageVars.height = document.documentElement["clientHeight"];
			}


			/*
			Global variables
			 */

			var objPageElements={
				rootanimate: null
			};
			var objPageVars={
				mobile: false
			}


			window.onload = initPage;
			window.onresize = onResize;


		</script>
	</body>
</html>    
